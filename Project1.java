/**
 * CS 4200
 * Professor: D. Atanasio
 *
 * Project #1
 *
 * 8-Puzzle: Implement the A* search to solve the 8-puzzle problem using both heuristics and compare their efficiency
 * in terms of depth of the solution and search costs. 
 * 				( h1 = the number of misplaced tiles )
 * 				( h2 = the sum of the distances of the tiles from their goal positions )
 * 
 * The user interface with provide at three menu options:
 * 
 * 1.) an option to generate a solvable random 8-random (generated by your program) then solve it using both heuristics. 
 * It should output the optimal sequence of states that result from the search, the solution depth and the search cost for 
 * each heuristic.
 * 
 * 2.) An option to input a specific 8-puzzle configuration. The input will contain the configuration for only one puzzle, in 
 * the following format (where 0 represents the empty tile and the digits are separated by a space)
 * 			124056837
 * 
 * This option should solve the entered puzzle and output the optimal sequence of states that result from the search, the 
 * solution depth and the search cost for each heuristic. 
 *
 * @author Eric Schenck
 * last modified: 10/13/17
 */

import java.util.Scanner;
import java.util.Random;
import java.lang.Math;
import java.util.Arrays;
import java.io.IOException;
import java.io.PrintWriter;

public class Project1{
	
	final static int[] GOAL_STATE = {0,1,2,3,4,5,6,7,8};
	
	/**
	 * used to return the inversion count of a puzzle state
	 * @param puzzleState
	 * @return the count of inversions
	 */
	public static int getInversionCount(int[] puzzleState) {
		
		int count = 0;
		
		for(int i = 0; i < 9 - 1 ; ++i) {
			for(int j = i+1; j < 9; ++j) {
				
				if(puzzleState[i] > puzzleState[j] && puzzleState[j] != 0) {
					++count;
				}
				
			}
		}
		return count;
	}
	
	/**
	 * used to determine whether or not a puzzle is solvable
	 * @param puzzleState
	 * @return true if solvable 
	 */
	public static boolean puzzleIsSolvable(int[] puzzleState) {
		
		boolean solvable;
		
		int inversionCount = getInversionCount(puzzleState);
		
		if(inversionCount%2 == 0) {
			solvable = true;
		}else
			solvable = false;
		
		return solvable;
		
	}
	
	public static int[] randomSolvableBoard() {
		Random rand = new Random();
		
		int[] output = {0,1,2,3,4,5,6,7,8};
		
		int tempVal;
		
		int first, second;
		boolean solvable = false;
		
		while(!solvable) {
		
			
			
				
				first = rand.nextInt(4);
				second = rand.nextInt(5)+4 ;
				
				tempVal = output[first];
				output[first] = output[second];
				output[second] = tempVal;
			
				
				
			
			
			
			if(puzzleIsSolvable(output)) {								//puzzle is solvable.  
				solvable = true;	
			}
			
			
		}
		
		
		return output;
	}
	
	
	
	
	
	
	public static int[] randomSolvableBoard1() {
		
		Random rand = new Random();											// rand
		
		boolean solvable = false;											// used to loop until a solvable puzzle is discovered
		
		int[] lastboard = new int[9];										
		
		while(!solvable) {									// loop while not solvable 
		
		
		int[] zeroLocation= {0,0};							// current zero location on new puzzle
		int randomNumMove, horizontalOrVertical;
	
		
		int iterator = 0;
		
		
		
		int[][] gameboard = new int[3][3];
		
		for(int i = 0; i<3; ++i) {
			for(int j =0; j<3; ++j) {
				gameboard[i][j] = iterator++;
			}
		}
		
		int maxMoves = rand.nextInt(50) + 2;
		
		for(int i = 0 ; i < maxMoves; ++i) {
			
			randomNumMove = rand.nextInt(2);					// 0 = up / left  &&   1 = down / right
			
		//	System.out.println("randNumMove = " + randomNumMove);
//			
			//System.out.println("zeroLocation = " + zeroLocation[0] + ", " + zeroLocation[1]);
//			
			horizontalOrVertical = rand.nextInt(2);				// 0 = Horizontal &&   1 = Vertical
			
			//System.out.println("horizOrVertical = " + horizontalOrVertical);
			
			if(zeroLocation[1] == 0 && randomNumMove == 0 && horizontalOrVertical == 0) { // cant move left
				randomNumMove = 1;
			
			}else if(zeroLocation[1] == 2 && randomNumMove == 1 && horizontalOrVertical == 0) { // cant move right
				randomNumMove = 0;
			
			}else if(zeroLocation[0] == 0 && randomNumMove == 0 && horizontalOrVertical == 1) { // cant move up
				randomNumMove = 1;
			
			}else if(zeroLocation[0] == 2 && randomNumMove == 1 && horizontalOrVertical == 1 ) { // cant move down
				randomNumMove = 0;
			}
			
			if(randomNumMove == 0) {
				randomNumMove = -1;
			}
			
			
			
			if(horizontalOrVertical == 0) {		// horizontal move
				gameboard = swap(gameboard, zeroLocation[0], zeroLocation[1], zeroLocation[0], zeroLocation[1] + randomNumMove);
				zeroLocation[1] += randomNumMove;
				
//				
			
			}else if(horizontalOrVertical == 1) { 	// vertical move
	
				gameboard = swap(gameboard, zeroLocation[0], zeroLocation[1], zeroLocation[0] + randomNumMove, zeroLocation[1]	);
				zeroLocation[0] += randomNumMove;
				
				
				
			}
			
		

		}
		
		iterator = 0;
		
		for(int i = 0; i<3; ++i) {
			for(int j = 0; j<3; ++j) {
				lastboard[iterator++] = gameboard[i][j];
			}
		}
		
	
		if(puzzleIsSolvable(lastboard)) {								//puzzle is solvable.  
			solvable = true;	
		}
		
		}// end of while loop
		
		return lastboard;
	}
	

	
	
	
	
	public static int[][] swap(int[][] gameboard, int i, int j, int k, int m) {
		int temp;
		
		temp = gameboard[i][j];
		gameboard[i][j] = gameboard[k][m];
		gameboard[k][m] = temp;
		
		return gameboard;
	}
	
	
	public static void runOption1(){
		
		Random rand = new Random();
		
		int whichBoard = rand.nextInt(100);
		int[] randomRoot;
		
		
		
		if(whichBoard % 2 == 1 ) {
			randomRoot =  randomSolvableBoard();				// gameboard	
		}else {
		randomRoot =  randomSolvableBoard1();				// gameboard	
		}
		
		
		
		for(int i=0; i<randomRoot.length; ++i) {
			System.out.print(randomRoot[i] + ", ");
		}
		System.out.println();
		
		PuzzleState root = new PuzzleState(randomRoot);
		
		System.out.println("\nMisplaced Heuristic : ");
		aStarSearch(root, 1);
		System.out.println("\nManhattan Heuristic : ");
		PuzzleState testState = aStarSearch(root, 2);
		
		int depth = testState.getDepth();
		String[] output = new String[depth];
		
		for(int i = 0; i < depth; ++i) {

			//System.out.println(Arrays.toString(testState.getCurrentState()));
			output[i] = (Arrays.toString(testState.getCurrentState()));
			testState = testState.getPreviousState();
		}
		
		while(depth > 0) {
			System.out.println(output[--depth]);
		}
		
		
		
		
		//System.out.println("\nSolved");
		
	}
	
	public static void runOption2(){
		
		int[] userConfig = new int[9];
		String[] userString;
		boolean loop = true;
		
		String input;
		
		Scanner keyboard1 = new Scanner(System.in);
		
		restart:
		while(loop) {
			System.out.println("Please enter an initial 8-puzzle configuration:");
			input = keyboard1.nextLine();
		
			//System.out.println(input);
		
			userString = input.split("\\s*(\\s|,|\\{|\\})\\s*");	// handles spaces and commas and brackets
		
			userString = handleInitialSpaces(userString);			// handles initial spaces if any
		
			try {
				for(int i = 0; i < userString.length; ++i) {
					userConfig[i] = Integer.parseInt(userString[i]);
				}
			}catch( Exception e) {
				System.out.println("Incorrect Input!");
				continue restart;
			}
			
			if(!correctLength(userConfig)) {
				System.out.println("Must enter EXACTLY 9 values, ex: {0,1,2,3,4,5,6,7,8}");
				continue restart;
			}
			
			if(repeatValuesExist(userConfig) || !correctNumericalRange(userConfig)) {
				System.out.println("Must enter non-repeating values 0 - 8, ex: {0,1,2,3,4,5,6,7,8}");
				continue restart;
			}
			
			
			
			if(getInversionCount(userConfig)%2 != 0) {
				System.out.println("Puzzle is not solvable, Please choose a different configuration...");
				continue restart;
			}
			
			
		
		
		PuzzleState root = new PuzzleState(userConfig);
		
		System.out.println("\nMisplaced Heuristic : ");
		aStarSearch(root, 1);
		System.out.println("\nManhattan Heuristic : ");
		PuzzleState testState = aStarSearch(root, 2);
		
		int depth = testState.getDepth();
		String[] output = new String[depth];
		
		for(int i = 0; i < depth; ++i) {

			//System.out.println(Arrays.toString(testState.getCurrentState()));
			output[i] = (Arrays.toString(testState.getCurrentState()));
			testState = testState.getPreviousState();
		}
		
		while(depth > 0) {
			System.out.println(output[--depth]);
		}
		
		loop = false; // used to end loop used for user input incase of incorrect entry
		}// end of while loop
		
		
		
		
	}
	
	public static void  runOption3() throws IOException{
		
		
		
		
		int size2 = 0;
		int size4 = 0;
		int size6 = 0;
		int size8 = 0;
		int size10 = 0;
		int size12 = 0; 
		int size14 = 0;
		int size16 = 0;
		int size18 = 0;
		int size20 = 0;
		int size22 = 0;
		int size24 = 0;
		
		long[][] depth2 = new long[1000][4];
		long[][] depth4 = new long[1000][4];
		long[][] depth6 = new long[1000][4];
		long[][] depth8 = new long[1000][4];
		long[][] depth10 = new long[1000][4];
		long[][] depth12 = new long[1000][4];
		long[][] depth14 = new long[1000][4];
		long[][] depth16 = new long[1000][4];
		long[][] depth18 = new long[1000][4];
		long[][] depth20 = new long[1000][4];
		long[][] depth22 = new long[1000][4];
		long[][] depth24 = new long[1000][4];
		

		
		long[][] storage = new long[2000][4];
		
		
		
		
		
		int storageCount = 0;
		
		for(int j=0; j< 100; ++j) {

			int[] randomRoot =  randomSolvableBoard();				// gameboard
			
			
		
			
			//long duration = (endTime1 - startTime1);  //divide by 1000000 to get milliseconds.	
			
			//System.out.println(Arrays.toString(randomRoot));
			
			PuzzleState root = new PuzzleState(randomRoot);
			
			System.out.println("\nMisplaced Heuristic : ");
			long startTime1 = System.nanoTime();
			PuzzleState h1 = aStarSearch(root, 1);
			long endTime1 = System.nanoTime();
			
			storage[storageCount][0] = h1.getDepth();
			storage[storageCount][1] = h1.getSearchCost();
			storage[storageCount][2] = 1;						// for heuristic 1
			storage[storageCount++][3] = (endTime1 - startTime1) ; // time in nano seconds
			
			System.out.println("\nManhattan Heuristic : ");
			long startTime2 = System.nanoTime();
			PuzzleState h2 = aStarSearch(root, 2);
			long endTime2 = System.nanoTime();
			
			storage[storageCount][0] = h2.getDepth();
			storage[storageCount][1] = h2.getSearchCost();
			storage[storageCount][2] = 2;						// for heuristic 2
			storage[storageCount++][3] = (endTime2 - startTime2)/1000000 ;
			
			
			System.out.println("depth = " + storage[storageCount - 1][0] + " & Time is = " + storage[storageCount -1][3]);
			
		}
			
		for(int i=0; i<storageCount-1; ++i) {
			
			if(storage[i][0] == 2) {
				
				depth2[size2][0] = storage[i][0];
				depth2[size2][1] = storage[i][1];
				depth2[size2][2] = storage[i][2];
				depth2[size2++][3] = storage[i][3];
				
			}else if(storage[i][0] == 4) {
				
				depth4[size4][0] = storage[i][0];
				depth4[size4][1] = storage[i][1];
				depth4[size4][2] = storage[i][2];
				depth4[size4++][3] = storage[i][3];
				
			}else if(storage[i][0] == 6) {
				depth6[size6][0] = storage[i][0];
				depth6[size6][1] = storage[i][1];
				depth6[size6][2] = storage[i][2];
				depth6[size6++][3] = storage[i][3];
				
			}else if(storage[i][0] == 8) {
				depth8[size8][0] = storage[i][0];
				depth8[size8][1] = storage[i][1];
				depth8[size8][2] = storage[i][2];
				depth8[size8++][3] = storage[i][3];
				
			}else if(storage[i][0] == 10) {
				
				depth10[size10][0] = storage[i][0];
				depth10[size10][1] = storage[i][1];
				depth10[size10][2] = storage[i][2];
				depth10[size10++][3] = storage[i][3];
				
			}else if(storage[i][0] == 12) {
				
				depth12[size12][0] = storage[i][0];
				depth12[size12][1] = storage[i][1];
				depth12[size12][2] = storage[i][2];
				depth12[size12++][3] = storage[i][3];
				
				
			}else if(storage[i][0] == 14) {
				
				depth14[size14][0] = storage[i][0];
				depth14[size14][1] = storage[i][1];
				depth14[size14][2] = storage[i][2];
				depth14[size14++][3] = storage[i][3];
				
			}else if(storage[i][0] == 16) {
				
				depth16[size16][0] = storage[i][0];
				depth16[size16][1] = storage[i][1];
				depth16[size16][2] = storage[i][2];
				depth16[size16++][3] = storage[i][3];
				
			}else if(storage[i][0] == 18) {
				depth18[size18][0] = storage[i][0];
				depth18[size18][1] = storage[i][1];
				depth18[size18][2] = storage[i][2];
				depth18[size18++][3] = storage[i][3];
			}else if(storage[i][0] == 20) {
				depth20[size20][0] = storage[i][0];
				depth20[size20][1] = storage[i][1];
				depth20[size20][2] = storage[i][2];
				depth20[size20++][3] = storage[i][3];
				
			}else if(storage[i][0] == 22) {
				depth22[size22][0] = storage[i][0];
				depth22[size22][1] = storage[i][1];
				depth22[size22][2] = storage[i][2];
				depth22[size22++][3] = storage[i][3];
				
				
			}else if(storage[i][0] == 24) {
				depth24[size24][0] = storage[i][0];
				depth24[size24][1] = storage[i][1];
				depth24[size24][2] = storage[i][2];
				depth24[size24++][3] = storage[i][3];
				
			}
			
			
			
		}
		
		
		size2 -=1;
		size4 -=1;
		size6 -=1;
		size8 -=1;
		size10 -=1;
		size12 -=1;
		size14 -=1;
		size16 -=1;
		size18 -=1;
		size20 -=1;
		size22 -=1;
		size24 -=1;
		
		
		
		PrintWriter outputFile = new PrintWriter("output.txt");
		outputFile.println("---------------------------------------------------------------------------------------------------------");
		outputFile.println(" depth  |    MisplaceTileHeuristic  |   ManhattanHeuristic     |   Avg runtime (nanosecs)  |  # cases   |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		long h1tempCost = 0;
		long h2tempCost = 0;
		long avgTime = 0;
		
		
		
		
		for(int j = 0;j < size2 -1; ++j) {
			
			if(depth2[j][2] == 1) {
				h1tempCost += depth2[j][1];
			}else
				h2tempCost += depth2[j][2];
			
			avgTime += depth2[j][3];
		}
		h1tempCost /= size2;
		h2tempCost /= size2;
		avgTime /= size2;
		
		outputFile.println("  " + 2 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size2 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
		
		for(int j = 0;j < size4 -1; ++j) {
			
			if(depth4[j][2] == 1) {
				h1tempCost += depth4[j][1];
			}else
				h2tempCost += depth4[j][2];
			
			avgTime += depth4[j][3];
		}
		h1tempCost /= size4;
		h2tempCost /= size4;
		avgTime /= size4;
		
		outputFile.println("  " + 4 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size4 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
for(int j = 0;j < size6 -1; ++j) {
			
			if(depth6[j][2] == 1) {
				h1tempCost += depth6[j][1];
			}else
				h2tempCost += depth6[j][2];
			
			avgTime += depth6[j][3];
		}
		h1tempCost /= size6;
		h2tempCost /= size6;
		avgTime /= size6;
		
		outputFile.println("  " + 6 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size6 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
for(int j = 0;j < size8 -1; ++j) {
			
			if(depth8[j][2] == 1) {
				h1tempCost += depth8[j][1];
			}else
				h2tempCost += depth8[j][2];
			
			avgTime += depth8[j][3];
		}
		h1tempCost /= size8;
		h2tempCost /= size8;
		avgTime /= size8;
		
		outputFile.println("  " + 8 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size8 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
for(int j = 0;j < size10 -1; ++j) {
			
			if(depth10[j][2] == 1) {
				h1tempCost += depth10[j][1];
			}else
				h2tempCost += depth10[j][2];
			
			avgTime += depth10[j][3];
		}
		h1tempCost /= size10;
		h2tempCost /= size10;
		avgTime /= size10;
		
		outputFile.println("  " + 10 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size10 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
for(int j = 0;j < size12 -1; ++j) {
			
			if(depth12[j][2] == 1) {
				h1tempCost += depth12[j][1];
			}else
				h2tempCost += depth12[j][2];
			
			avgTime += depth12[j][3];
		}
		h1tempCost /= size12;
		h2tempCost /= size12;
		avgTime /= size12;
		
		outputFile.println("  " + 12 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size12 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
for(int j = 0;j < size14 -1; ++j) {
			
			if(depth14[j][2] == 1) {
				h1tempCost += depth14[j][1];
			}else
				h2tempCost += depth14[j][2];
			
			avgTime += depth14[j][3];
		}
		h1tempCost /= size14;
		h2tempCost /= size14;
		avgTime /= size14;
		
		outputFile.println("  " + 14 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size14 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
		
for(int j = 0;j < size16 -1; ++j) {
			
			if(depth16[j][2] == 1) {
				h1tempCost += depth16[j][1];
			}else
				h2tempCost += depth16[j][2];
			
			avgTime += depth16[j][3];
		}
		h1tempCost /= size16;
		h2tempCost /= size16;
		avgTime /= size16;
		
		outputFile.println("  " + 16 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size16 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
		
for(int j = 0;j < size18 -1; ++j) {
			
			if(depth18[j][2] == 1) {
				h1tempCost += depth18[j][1];
			}else
				h2tempCost += depth18[j][2];
			
			avgTime += depth18[j][3];
		}
		h1tempCost /= size18;
		h2tempCost /= size18;
		avgTime /= size18;
		
		outputFile.println("  " + 18 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size18 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		
		
for(int j = 0;j < size20 -1; ++j) {
			
			if(depth20[j][2] == 1) {
				h1tempCost += depth20[j][1];
			}else
				h2tempCost += depth20[j][2];
			
			avgTime += depth20[j][3];
		}
		h1tempCost /= size20;
		h2tempCost /= size20;
		avgTime /= size20;
		
		outputFile.println("  " + 20 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size20 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		

for(int j = 0;j < size22 -1; ++j) {
			
			if(depth22[j][2] == 1) {
				h1tempCost += depth22[j][1];
			}else
				h2tempCost += depth22[j][2];
			
			avgTime += depth22[j][3];
		}
		h1tempCost /= size22;
		h2tempCost /= size22;
		avgTime /= size22;
		
		outputFile.println("  " + 22 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size22 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		h1tempCost = 0;
		h2tempCost = 0;
		avgTime = 0;
		

for(int j = 0;j < size24 -1; ++j) {
			
			if(depth24[j][2] == 1) {
				h1tempCost += depth24[j][1];
			}else
				h2tempCost += depth24[j][2];
			
			avgTime += depth24[j][3];
		}
		h1tempCost /= size24;
		h2tempCost /= size24;
		avgTime /= size24;
		
		outputFile.println("  " + 24 + "  |           "  + h1tempCost   + "             |            " +  h2tempCost  + "             |             "
				+ avgTime + "          |    " + size24 + "    |");
		outputFile.println("----------------------------------------------------------------------------------------------------------");
		
		
		
		
		
		outputFile.close();
		
	}
	
	/**
	 * finds and returns the empty tile or 0 tile
	 * @param input
	 * @return
	 */
	public static int[] findEmptyTile(int[] input) {
		
		int[] index = {0,0};
		int counter = 0;
		
		
		for(int i = 0; i<3; ++i) {
			for(int j= 0; j<3;++j) {
				if(input[counter++] == 0) {
					index[0] = i;
					index[1] = j;
				}
			}
		}
		
		return index;
	}
	
	
	public static PuzzleState aStarSearch(PuzzleState root, int hType) {
		
		
		PuzzleState goalState = new PuzzleState(root.getCurrentState());
		
		PuzzleState childState;
		
		MinHeap frontier = new MinHeap();
		
		int[] zeroLocation = {0,0};
		int counter = 0;
		int costCounter = 0;										// used to count search cost in search 
		int moveLeft = -1;
		int moveRight = 1;
		int moveUp = -1;
		int moveDown = 1;
		
		
		int index = 0;
		
		
		PuzzleState parentState;
		
		frontier.addSequential(root);
		
		
		
		search: while(!frontier.heapIsEmpty() /*&& testCount < 3*/) {						// continue to loop as long as the frontier is not empty
			
			
			// or the solution is found and loop breaks
			parentState = frontier.dequeue();
		
			
			
			if(Arrays.equals(GOAL_STATE, parentState.getCurrentState())) {
				
				for(int i = 0 ; i < parentState.getDepth(); ++i) {
					
				}
				//System.out.println(Arrays.toString(parentState.getCurrentState()));
				
				
				System.out.println("Depth = " + parentState.getDepth());
				System.out.println("Search Cost = " + parentState.getSearchCost());
				System.out.println("***************************************************");
				goalState = parentState;
				// output optimal sequence of states , solution depth, and search cost for each heuristic
				
				break search;
			}
			
			int swapCount = 0;
			
			int[] tempState = new int[9];
			

			
			int[][] origBoard = new int[3][3];
			
			int[][] rightBoard = new int[3][3];
			
			int[][] leftBoard = new int[3][3];
			
			int[][] upBoard = new int[3][3];
			
			int [][] downBoard = new int[3][3];
			
			moveLeft = -1;
			moveRight = 1;
			moveUp = -1;
			moveDown = 1;
			
				
			zeroLocation = findEmptyTile(parentState.getCurrentState());			// find empty tile location
			
			
			
			counter = 0;
			
			for(int i = 0; i<3; ++i) {
				for(int j = 0; j<3; ++j) {
					leftBoard[i][j] = parentState.getCurrentState()[counter] ;
					rightBoard[i][j] = parentState.getCurrentState()[counter] ;
					upBoard[i][j] = parentState.getCurrentState()[counter] ;
					downBoard[i][j] = parentState.getCurrentState()[counter++] ;
				
				}
			}
			
			
			
			
			
				if(zeroLocation[1] == 0) {				// cant move left
					
					moveLeft = 0;
					
				}else if(zeroLocation[1] == 2) {				// cant move right
				
					moveRight = 0;
				}
				if(zeroLocation[0] == 0) {				// cant move up
					
					moveUp = 0;
					
				}else if(zeroLocation[0] == 2) {		// cant move down
					
					moveDown = 0;
					
				}
				
				index = 0;								// reset index
				
				
									// four possible moves (up down left right)
					
				if(moveLeft!= 0) {// can make move left
					
					
					//tempboard = swap(origBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  , zeroLocation[1] + moveLeft);
					
					
					swap(leftBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  , zeroLocation[1] + moveLeft);
					//tempboard = origBoard;

					
					
					index=0;
					
					for(int i = 0; i<3; ++i) {
						for(int j= 0; j<3; ++j) {
							tempState[index++] = leftBoard[i][j];
						
						}
					}
					
					
					
						
					childState = new PuzzleState(tempState);
					
					
					
					
					if(hType == 1) {		// use misplaceHeuristic
						childState.setHeuristic(misplaceHeuristic(tempState));
					}else if(hType == 2) {  // use manhattanHeuristic
						childState.setHeuristic(manhattanHeuristic(tempState));
					}
					
						childState.setDepth(parentState.getDepth() + 1);				// every childState is 1 node deeper than its parent
						
						childState.setHeapValue();										// this value is used for the heap ( depth + Heuristic)
						
						childState.setPreviousState(parentState);
																			// set previousState of childState to parent
						if(parentState.getPreviousState() != null) { 
							if(!Arrays.equals(parentState.getPreviousState().getCurrentState(), childState.getCurrentState())) { // not to repeat past moves
								childState.setSearchCost(++costCounter);
								frontier.addSequential(childState);							// MinHeap based on heuristic value
							}						
						}else {
							childState.setSearchCost(++costCounter);
							frontier.addSequential(childState);							// MinHeap based on heuristic value
						}
						
						
						swapCount = 0;
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								origBoard[i][j] = 
										parentState.getCurrentState()[swapCount++];
							
							
							}
						}
						swapCount =0;
						

						
					}
					
					if(moveRight!= 0) {// can make move right
						
						
						//tempboard = swap(origBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]   , zeroLocation[1] + moveRight);
						
						swap(rightBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]   , zeroLocation[1] + moveRight);
						//tempboard = origBoard;
						
						index=0;
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								
								tempState[index++] = rightBoard[i][j];
							}
						}
						
						childState = new PuzzleState(tempState);
						
						
						
						
						if(hType == 1) {		// use misplaceHeuristic
							childState.setHeuristic(misplaceHeuristic(tempState));
						}else if(hType == 2) {  // use manhattanHeuristic
							childState.setHeuristic(manhattanHeuristic(tempState));
						}
						
					
					
						childState.setDepth(parentState.getDepth() + 1);				// every childState is 1 node deeper than its parent
						
						
						childState.setHeapValue();										// this value is used for the heap ( depth + Heuristic)
						
						
						childState.setPreviousState(parentState);
						
						
																			// set previousState of childState to parent
						
						if(parentState.getPreviousState() != null) { 
							if(!Arrays.equals(parentState.getPreviousState().getCurrentState(), childState.getCurrentState())) { // not to repeat past moves
								childState.setSearchCost(++costCounter);
								frontier.addSequential(childState);							// MinHeap based on heuristic value
							}						
						}else {
							childState.setSearchCost(++costCounter);
							frontier.addSequential(childState);							// MinHeap based on heuristic value
						}
						
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								origBoard[i][j] = 
										parentState.getCurrentState()[swapCount++];
							
							
							}
						}
						swapCount =0;
						
					}
					
					if(moveUp!= 0) {// can make move up
					
						
						//tempboard = swap(origBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  + moveUp , zeroLocation[1]);
						
						swap(upBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  + moveUp , zeroLocation[1]);
						//tempboard = origBoard;
						
						index=0;
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								tempState[index++] = upBoard[i][j];
							}
						}
						
						childState = new PuzzleState(tempState);
						
						
					
						if(hType == 1) {		// use misplaceHeuristic
							childState.setHeuristic(misplaceHeuristic(tempState));
						}else if(hType == 2) {  // use manhattanHeuristic
							childState.setHeuristic(manhattanHeuristic(tempState));
						}
					
						childState.setDepth(parentState.getDepth() + 1);				// every childState is 1 node deeper than its parent
						childState.setHeapValue();										// this value is used for the heap ( depth + Heuristic)
						childState.setPreviousState(parentState);
																			// set previousState of childState to parent
						
						if(parentState.getPreviousState() != null) { 
							if(!Arrays.equals(parentState.getPreviousState().getCurrentState(), childState.getCurrentState())) { // not to repeat past moves
								childState.setSearchCost(++costCounter);
								frontier.addSequential(childState);							// MinHeap based on heuristic value
							}						
						}else {
							childState.setSearchCost(++costCounter);
							frontier.addSequential(childState);							// MinHeap based on heuristic value
						}
						
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								origBoard[i][j] = 
										parentState.getCurrentState()[swapCount++];
							
							
							}
						}
						swapCount =0;
					}
					
					if(moveDown!= 0) {// can make move down
						
						
						//tempboard = swap(origBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  + moveDown , zeroLocation[1]);
						
						swap(downBoard, zeroLocation[0], zeroLocation[1], zeroLocation[0]  + moveDown , zeroLocation[1]);
						//tempboard = origBoard;
						
						index=0;
						
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								tempState[index++] = downBoard[i][j];
							}
						}
						
						childState = new PuzzleState(tempState);
						
						
						
						if(hType == 1) {		// use misplaceHeuristic
							childState.setHeuristic(misplaceHeuristic(tempState));
						}else if(hType == 2) {  // use manhattanHeuristic
							childState.setHeuristic(manhattanHeuristic(tempState));
						}
					
						childState.setDepth(parentState.getDepth() + 1);				// every childState is 1 node deeper than its parent
						childState.setHeapValue();										// this value is used for the heap ( depth + Heuristic)
						childState.setPreviousState(parentState);
																			// set previousState of childState to parent
						
						if(parentState.getPreviousState() != null) { 
							if(!Arrays.equals(parentState.getPreviousState().getCurrentState(), childState.getCurrentState())) { // not to repeat past moves
								childState.setSearchCost(++costCounter);
								frontier.addSequential(childState);							// MinHeap based on heuristic value
							}						
						}else {
							childState.setSearchCost(++costCounter);
							frontier.addSequential(childState);							// MinHeap based on heuristic value
						}
						
						for(int i = 0; i<3; ++i) {
							for(int j= 0; j<3; ++j) {
								origBoard[i][j] = 
										parentState.getCurrentState()[swapCount++];
							
							
							}
						}
						swapCount =0;
						
						
					}
				
					
					
			}
		return goalState;
	}
	
	
	
	
	
	
	
	
	/**
	 * checks for an initial space entered and re-adjusts String array if initial space is found
	 * @param splitUserSel
	 * @return
	 */
	public static String[] handleInitialSpaces(String[] splitUserSel){

		try{
			splitUserSel[0].charAt(0);			// handling issue of initial entered space
		}catch(Exception e){
		
			for(int i = 0; i < splitUserSel.length - 1 ; ++i){
				splitUserSel[i] = splitUserSel[i+1];
				splitUserSel[i+1] = null;
			}
		}
		return splitUserSel;
	}
	
	/**
	 * returns true if user entered correct length of game board 
	 * @param input
	 * @return
	 */
	public static boolean correctLength(int[] input) {
		String temp = " ";
		
		int zeroCount = 0;
		
		for(int i = 0; i < input.length ; ++i) {
			if(input[i] == 0)
				++zeroCount;
			temp += input[i];
		}
		
		if(zeroCount != 1)
			return false;
		else 
			return true;
	}
	
	/**
	 * Checks user input to make sure all values are with range 0 -8 
	 * @param input
	 * @return
	 */
	public static boolean correctNumericalRange(int[] input) {
		boolean inRange = true;
		
		for(int i = 0; i< input.length; ++i) {
			if(input[i] <= 8 && input[i] >= 0) {
				inRange = true;
			}else
				inRange = false;						// false if the value is not within range 0 - 8 
		}
		
		return inRange;
	}
	
	
	/**
	 * checks user input for repeat values 
	 * @param input
	 * @return
	 */
	public static boolean repeatValuesExist(int [] input) {
		
		boolean existing = false;							// default value
		
		A: for(int i= 0; i< input.length - 1; ++i) {		// checks input for repeat values 
			for(int j = i+1; j < input.length; ++j) {
				if(input[i] == input[j]) {
					existing = true;
					break A;								// if a match is found there is no reason to continue searching. 
				}else
					existing = false;
			}
		}
		
		
		return existing;
	}
	
	public static int misplaceHeuristic(int []input) {
		int misplaced = 0;
		
		for(int i = 0; i < input.length; ++i) {
			if(input[i] != i) {
				++misplaced;
			}
		}
		
		return misplaced;
		
	}
	
	public static int manhattanHeuristic(int[] input) {
		int totalDist = 0;
		
		int iterator = 0;
		
		int[][] gameboard = new int[3][3];
		
		
		for(int i = 0; i<3;++i) {
			for(int j=0; j<3; ++j) {
				gameboard[i][j] = input[iterator++];
			}
		}
		
		
		iterator = 0;
		for(int i = 0; i < 3; ++i) {
			for(int j=0; j<3; ++j) {
				
				if(iterator == 0) {
					++j;			// dont count moving the 0 since its an empty tile
					++iterator;
				}
				search: for(int k=0; k<3; ++k) {	// going thru actual gameboard and finding number of moves to correct tile location
					for(int m=0; m<3; ++m) {
						
						if(gameboard[k][m] == iterator) {
							totalDist += (Math.abs(k-i) + Math.abs(m-j));
							break search;
						}
					}
				}
				
				++iterator;
				
			}
		}
		
		return totalDist;
		
	}
	


	public static void main(String[] args){
		
		Scanner keyboard = new Scanner(System.in);							// used for user input
		
		int userChoice = 0;
		
		System.out.println("Hello...");
		System.out.println("Please choose from the following menu: (Enter 1,2,or 3)");
		System.out.println("---------------------------------------------");
		System.out.println("Option 1 : Randomly generate a solvable random 8-puzzle problem and display the solution.");
		System.out.println("Option 2 : Enter a specific 8-puzzle configuration and display the solution if solvable.");
		System.out.println("Option 3 : Randomly generate >1000 test cases and print analysis at variety of depths to outputfile.");
		System.out.print("(Enter 1,2, or 3) : " );
		
		try{
			userChoice = keyboard.nextInt();
			if(userChoice == 1){
				runOption1();						// Option 1 : random generate and solve one puzzle
			}else if(userChoice == 2){
				runOption2();						// Option 2 : user input puzzle state and solve if possible
			}else if(userChoice == 3){
				runOption3();						// Option 3 : random generate over 1000 test cases with analysis printout 
			}else{
				System.out.println("Incorrect input. Goodbye");
				keyboard.close();
				System.exit(0);												
			}
		}catch( Exception e){												 
			System.out.println("Incorrect input. Goodbye");
		}
		keyboard.close();		
	}
	
	
}
