/**
 * CS 4200
 * Professor: D. Atanasio
 *
 * Project #1
 *
 * 8-Puzzle: Implement the A* search to solve the 8-puzzle problem using both heuristics and compare their efficiency
 * in terms of depth of the solution and search costs. 
 * 				( h1 = the number of misplaced tiles )
 * 				( h2 = the sum of the distances of the tiles from their goal positions )
 * 
 * The user interface with provide at three menu options:
 * 
 * 1.) an option to generate a solvable random 8-random (generated by your program) then solve it using both heuristics. 
 * It should output the optimal sequence of states that result from the search, the solution depth and the search cost for 
 * each heuristic.
 * 
 * 2.) An option to input a specific 8-puzzle configuration. The input will contain the configuration for only one puzzle, in 
 * the following format (where 0 represents the empty tile and the digits are separated by a space)
 * 			124056837
 * 
 * This option should solve the entered puzzle and output the optimal sequence of states that result from the search, the 
 * solution depth and the search cost for each heuristic. 
 *
 * @author Eric Schenck
 * last modified: 10/13/17
 */

public class PuzzleState {

	
	private int[] currentState = new int[9];							// current state of game board
	
	private int depth = 0;							// initially set to zero
	
	private int searchCost;						
	
	private int heuristicValue;					// initially set to zero
	
	private int heapValue;						// heapValue = depth + heuristic        // this way the algorithm will search lower depths first to find optimal path
	
	private PuzzleState previousState = null;							// to hold parent State for comparison
	
	public PuzzleState(int[] state){
		
		for(int i = 0; i < 9; ++i) {
			currentState[i] = state[i];
		}
		
	}
	
	public void setHeapValue() {
		heapValue = depth + heuristicValue;
	}
	
	public int getHeapValue() {
		return heapValue;
	}
	
	public String toString() {
		String str = "";
		
		
		for(int i = 0; i<9; ++i) {
			str += currentState[i] + ", ";
		}
		
		return str;
	}
	
	public void setSearchCost(int cost) {
		searchCost = cost;
	}
	public int getSearchCost() {
		return searchCost;
	}
	
	public void setDepth(int dpt) {
		depth = dpt;
	}
	public int getDepth() {
		return depth;
	}
	
	public void setHeuristic(int heuristic) {
		heuristicValue = heuristic;
	}
	public int getHeuristic() {
		return heuristicValue;
	}
	
	//public void setTransitionStates(PuzzleState)
	
	
	/**
	 * allows previousState to be set
	 * @param parent state
	 */
	public void setPreviousState(PuzzleState parent){
		previousState = parent;
	}
	
	/**
	 * returns previousState when called
	 * @return
	 */
	public PuzzleState getPreviousState(){
		return previousState;
	}
	
	/**
	 * returns current state in form of int[]
	 * @return
	 */
	public int[] getCurrentState(){
		return currentState;
	}
	
	
	
}
